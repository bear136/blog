### 一、前言
当我们需要衡量一个网页的性能时，我们需要根据工具计算出特定的性能指标，例如：**FP (首次绘制) ， FCP（首次内容绘制）**，**FID (首次输入延迟)**，** LCP(最大内容绘制)**等等。 我们根据所收集到的性能指标，针对性的使用各种优化手段进行优化。这就是我们常说的前端性能优化。 
### 二、性能指标 
![](https://cdn.nlark.com/yuque/0/2023/png/27018002/1692277551310-ee58d8ed-cfe3-4866-aa66-a83bdda5a6ab.png#averageHue=%23f9f9f9&clientId=u5e9452fd-07e4-4&from=paste&id=u8de23b02&originHeight=649&originWidth=1002&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=uaecf2c14-c166-49c0-83d1-b7ca076cebc&title=)<br />性能指标的分类方式很多，我们针对性的介绍下列几个较为重要的性能指标@[前端监控之数据采集](https://feuux5hgzd.feishu.cn/docx/VripdHjBLoeEMmxAeUHcqrhLnVd)
### 三、性能优化的方法
主要将性能优化分为两个大类：

- 加载时优化 （缩短请求时间）
- 渲染时优化

顾名思义**加载时优化**也就是优化网站获取资源的一个速度，缩短请求时间，即让网站加载的更快。 **渲染时优化**则是在页面进行渲染时，提高页面渲染速度，减少卡顿等
### 加载时优化
##### DNS预解析
当我们需要访问一个网站时，首先需要进行的则是进行DNS解析。减少DNS解析次数和时间是一个很好的优化方式。 <br />**DNS预解析：**拥有此属性的域名不需要用户点击就可以实现在后台解析，且域名解析和内容载入是串行的网络操作。 <br />**实现：**<br />使用meta告知浏览器，当前页面需要进行DNS预解析 
```
<meta http-equiv='x-dns-prefetch-control' content='on'>
```
##### HTTP2
HTTP2带来了很多的加载优化，例如：

- 多路复用
- 头部压缩
- 服务器推送 
##### 减少HTTP请求数量
当我们要发送一个HTTP请求时，需要经历建立连接->发送请求->接受请求->断开连接等步骤，这些步骤都是需要花费时间的，如果页面的请求非常的碎片化，即每次请求获取到很小的数据（小图标），那么对性能是非常浪费的。 **雪碧图**则是减少http请求数量的一个很好的例子<br />**雪碧图：** 将图片进行合并，形成雪碧图。不同图标的background-url都会设置为一个相同的url，同时使用背景偏移量进行选择合适的图标。
##### 减少HTTP请求大小
###### 压缩合并文件 
我们在打包构建代码时，可以对html，js，css以及图片等文件进行压缩处理，减少资源体积，减少请求时间。 
###### TreeShaking 
打包代码过程中，对于导出但未被使用的模块进行删除。这样可以减少打包资源的体积。
###### 懒加载 

- **路由懒加载： **如果项目中存在多个路由，如果同时将这些页面都打包进一个js文件中，虽然减少的请求次数，但是会导致文件比较大，同时加载了大量首页不需要的资源，得不偿失。此时**使用按需加载（路由懒加载），将路由页面单独打包成一个文件，在进入该路由时再进行加载即可。**
- **组件懒加载**
- **图片懒加载: **当图片到达可视区后再加载图片。
##### 服务端渲染 
服务器渲染好html后，客户端只进行解析。优点：首屏优化快 SEO好。
##### 静态资源CDN加速
用户与服务器之间的物理距离对响应时间也有影响。CDN即在多个位置部署服务器，让用户离服务器更近，从而缩短请求时间。
### 渲染时优化
##### 减少重排重绘

- 元素位置变换时尽量使用css3的transfrom来代替top left的操作，因为变换仅仅影响图层的组合位置 
- 使用opacity来代替visibility，因为透明度并不触发重绘 

**注 **：透明度改变时GPU在绘画时只是简单的降低之前画好纹理的alpha值来达到效果 

- 将多次class样式改变操作合并为一次（预先定义改变后的class）
- 使用display:none将dom元素离线后修改 
- 利用文档碎片documentFragment收集短时间内回流元素后一次回流添加到页面（vue同款优化） 
- 动画实现过程中使用transfrom:tranleteZ(0)使其提升为合成层通过GPU单独渲染 
- 为动画元素新建图层并提高其z-index以减少隐式合成 
- 减少对flush队列的访问，尽量不要破坏浏览器自身优化 
- 单调色块可使用合成层优化中的scale缩放来优化内存占用 
- CSS在上JS在下，触发浏览器的first paint且减少同步代码阻塞渲染的机率 
##### 辅助计算 webworker
当前端需要大量数据计算或长时间占用线程的事件时，为了防止浏览器假死或者卡顿的情况，通常使用以下方法：

- **计算切片**：  使用setTimeout拆分密集型任务，将计算进行切片操作。
- **WebWorker** :

独立的一个线程，完全和主线程并行执行的js代码，并不会堵塞UI。通常使用postMessage 和 onMessage进行通信
##### 用户体验度优化
###### 长列表优化：虚拟列表 
虚拟列表是一种用来优化长列表的技术。它可以保证在列表元素不断增加，或者列表元素很多的情况下，依然拥有很好的滚动、浏览性能。它的核心思想在于：只渲染可见区域附近的列表。
###### 优化滚动事件
使用防抖节流进行优化
###### 动画优化

- 使用css实现动画，而不是js
- 尽可能多的使用transform和optical
- translateZ/translate3D开启硬件加速
- js动画使用requestAnimationFrame少用setInterval
### 四、如何解决页面字体抖动

1. Font-display
- Block: 浏览器首先使用隐形文字替代页面上的文字，等字体加载完成之后再显示
- Swap : 如果设定的子题还未使用，则首先使用备用字体显示，当加载完成后进行替换
2. 预加载：
- 对字体进行预加载，提升字体资源加载的优先级
### 五、图片选择
#### JPEG / JPG 
文件后缀名为 ".jpeg"或 ".jpg" ， 是一种常用的图像文件格式。 是一种有损压缩格式，能够将图片压缩在很小的储存空间，图像中重复或者不重要的资料会被丢失，因此容易造成图像数据的损伤。
##### 优点：

- 采取有损压缩，压缩后体积更小 
- 支持24位真彩色 
- 支持渐进式加载 
##### 缺点：

1. 有损压缩会损坏图片的质量 
2. 不支持透明和半透明 
##### 适用场景：
适用于呈现色彩较为丰富的图片，常作为背景图、轮播图、或Banner图出现
#### PNG
PNG即便携式网络图形，是一种无损压缩的格式，具备一些GIF文件所不具备的特征。 PNG支持8位、24位、32位3种格式。
##### 优点： 

- 无损压缩，保证图片质量
- 支持透明、半透明 
- 最高支持24位真彩色以及8位灰度图像，彻底消除锯齿边缘 
##### 缺点：

1. png所提供的压缩量较小，压缩能力有限 
2. 不支持动画 
##### 适用场景：
呈现小的Logo，色彩简单且对比强烈的图片或背景
#### WEBP
由谷歌推出，这种格式的图片支持**有损压缩**、**无损压缩**两种格式，主要特点是**体积小 。 **
##### 缺点：

- 旧版本浏览器的兼容性不好，需考虑兼容性问题。 
##### 适用场景：
几乎适用于各种场景，但是兼容性不好，如果需要使用则需要进行降级处理 
#### SVG
SVG通常用于描述二维矢量/栅格图形，且SVG图形是可交互的和动态的，可以在SVG文件种嵌入动画元素或通过JavaScript定义动画 
##### 优点：

- 尺寸更小，可压缩性更强
- 可伸缩，放大缩小不失真
- 可以与Javascript进行交互使用 
##### 缺点：

- 渲染成本对于其他格式的图片较高，对性能有影响。 
##### 适用场景：
常用于平面图的绘制，例如绘制线条、多边形等 ，数据可视化等方面 
